import { Callout, Tabs, Tab } from 'nextra-theme-docs'

## `application()` function
<Tabs items={[
    <code>typia</code>,
    <code>ILlmApplication</code>,
    <code>ILlmFunction</code>,
    <code>ILlmSchema</code>,
  ]}>
  <Tab>
```typescript filename="typia"
export namespace llm {
  export function application<App extends object>(
    options?: ILlmApplication.IOptions
  ): ILlmApplication;
}
```
  </Tab>
  <Tab>
```typescript filename="@samchon/openapi" showLineNumbers
/**
 * Application of LLM function calling.
 *
 * `ILlmApplication` is a data structure representing a collection of
 * {@link ILlmFunction LLM function calling schemas}, composed from a native
 * TypeScript class (or interface) type by the `typia.llm.application<App>()`
 * function.
 *
 * By the way, the LLM function calling application composition, converting
 * `ILlmApplication` instance from TypeScript interface (or class) type is not always
 * successful. As LLM provider like OpenAI cannot understand the recursive reference
 * type that is embodied by {@link OpenApi.IJsonSchema.IReference}, if there're some
 * recursive types in the TypeScript interface (or class) type, the conversion would
 * be failed.
 *
 * Also, there can be some parameters (or their nested properties) which must be
 * composed by Human, not by LLM. File uploading feature or some sensitive information
 * like secrety key (password) are the examples. In that case, you can separate the
 * function parameters to both LLM and human sides by configuring the
 * {@link ILlmApplication.IOptions.separate} property. The separated parameters are
 * assigned to the {@link ILlmFunction.separated} property.
 *
 * For reference, when both LLM and Human filled parameter values to call, you can
 * merge them by calling the {@link HttpLlm.mergeParameters} function. In other words,
 * if you've configured the {@link ILlmApplication.IOptions.separate} property, you
 * have to merge the separated parameters before the funtion call execution.
 *
 * @reference https://platform.openai.com/docs/guides/function-calling
 * @author Jeongho Nam - https://github.com/samchon
 */
export interface ILlmApplication<Schema extends ILlmSchema = ILlmSchema> {
  /**
   * List of function metadata.
   *
   * List of function metadata that can be used for the LLM function call.
   */
  functions: ILlmFunction<Schema>[];

  /**
   * Options for the document.
   */
  options: ILlmApplication.IOptions<Schema>;
}
export namespace ILlmApplication {
  export interface IOptions<Schema extends ILlmSchema = ILlmSchema> {
    /**
     * Separator function for the parameters.
     *
     * When composing parameter arguments through LLM function call,
     * there can be a case that some parameters must be composed by human,
     * or LLM cannot understand the parameter. For example, if the
     * parameter type has configured
     * {@link ILlmSchema.IString.contentMediaType} which indicates file
     * uploading, it must be composed by human, not by LLM
     * (Large Language Model).
     *
     * In that case, if you configure this property with a function that
     * predicating whether the schema value must be composed by human or
     * not, the parameters would be separated into two parts.
     *
     * - {@link ILlmFunction.separated.llm}
     * - {@link ILlmFunction.separated.human}
     *
     * When writing the function, note that returning value `true` means
     * to be a human composing the value, and `false` means to LLM
     * composing the value. Also, when predicating the schema, it would
     * better to utilize the {@link LlmTypeChecker} features.
     *
     * @param schema Schema to be separated.
     * @returns Whether the schema value must be composed by human or not.
     * @default null
     */
    separate: null | ((schema: Schema) => boolean);
  }
}
```
  </Tab>
  <Tab>
```typescript filename="@samchon/openapi" showLineNumbers
/**
 * LLM function metadata.
 *
 * `ILlmFunction` is an interface representing a function metadata,
 * which has been used for the LLM (Language Large Model) function
 * calling. Also, it's a function structure containing the function
 * {@link name}, {@link parameters} and {@link output return type}.
 *
 * If you provide this `ILlmFunction` data to the LLM provider like "OpenAI",
 * the "OpenAI" will compose a function arguments by analyzing conversations
 * with the user. With the LLM composed arguments, you can execute the function
 * and get the result.
 *
 * By the way, do not ensure that LLM will always provide the correct
 * arguments. The LLM of present age is not perfect, so that you would
 * better to validate the arguments before executing the function.
 * I recommend you to validate the arguments before execution by using
 * [`typia`](https://github.com/samchon/typia) library.
 *
 * @reference https://platform.openai.com/docs/guides/function-calling
 * @author Jeongho Nam - https://github.com/samchon
 */
export interface ILlmFunction<Schema extends ILlmSchema = ILlmSchema> {
  /**
   * Representative name of the function.
   */
  name: string;

  /**
   * List of parameter types.
   */
  parameters: Schema[];

  /**
   * Collection of separated parameters.
   */
  separated?: ILlmFunction.ISeparated<Schema>;

  /**
   * Expected return type.
   *
   * If the function returns nothing (`void`), the `output` value would
   * be `undefined`.
   */
  output?: Schema | undefined;

  /**
   * Description of the function.
   *
   * For reference, the `description` is very important property to teach
   * the purpose of the function to the LLM (Language Large Model), and
   * LLM actually determines which function to call by the description.
   *
   * Also, when the LLM conversates with the user, the `description` is
   * used to explain the function to the user. Therefore, the `description`
   * property has the highest priroity, and you have to consider it.
   */
  description?: string | undefined;
}
export namespace ILlmFunction {
  /**
   * Collection of separated parameters.
   */
  export interface ISeparated<Schema extends ILlmSchema = ILlmSchema> {
    /**
     * Parameters that would be composed by the LLM.
     */
    llm: ISeparatedParameter<Schema>[];

    /**
     * Parameters that would be composed by the human.
     */
    human: ISeparatedParameter<Schema>[];
  }

  /**
   * Separated parameter.
   */
  export interface ISeparatedParameter<Schema extends ILlmSchema = ILlmSchema> {
    /**
     * Index of the parameter.
     *
     * @type uint
     */
    index: number;

    /**
     * Type schema info of the parameter.
     */
    schema: Schema;
  }
}
```
  </Tab>
  <Tab>
```typescript filename="@samchon/openapi" showLineNumbers
/**
 * Type schema info of LLM function call.
 *
 * `ILlmSchema` is a type metadata of LLM (Large Language Model)
 * function calling.
 *
 * `ILlmSchema` basically follows the JSON schema definition of OpenAPI
 * v3.0 specification; {@link OpenApiV3.IJsonSchema}. However, `ILlmSchema`
 * does not have the reference type; {@link OpenApiV3.IJsonSchema.IReference}.
 * It's because the LLM cannot compose the reference typed arguments.
 *
 * For reference, the OpenAPI v3.0 based JSON schema definition can't
 * express the tuple array type. It has been supported since OpenAPI v3.1;
 * {@link OpenApi.IJsonSchema.ITuple}. Therefore, it would better to avoid
 * using the tuple array type in the LLM function calling.
 *
 * @reference https://platform.openai.com/docs/guides/function-calling
 * @author Jeongho Nam - https://github.com/samchon
 */
export type ILlmSchema =
  | ILlmSchema.IBoolean
  | ILlmSchema.IInteger
  | ILlmSchema.INumber
  | ILlmSchema.IString
  | ILlmSchema.IArray
  | ILlmSchema.IObject
  | ILlmSchema.IUnknown
  | ILlmSchema.INullOnly
  | ILlmSchema.IOneOf;
export namespace ILlmSchema {
  /**
   * Boolean type schema info.
   */
  export interface IBoolean extends __ISignificant<"boolean"> {
    /**
     * Default value.
     */
    default?: boolean | null;

    /**
     * Enumeration values.
     */
    enum?: Array<boolean | null>;
  }

  /**
   * Integer type schema info.
   */
  export interface IInteger extends __ISignificant<"integer"> {
    /**
     * Default value.
     *
     * @type int64
     */
    default?: number | null;

    /**
     * Enumeration values.
     *
     * @type int64
     */
    enum?: Array<number | null>;

    /**
     * Minimum value restriction.
     *
     * @type int64
     */
    minimum?: number;

    /**
     * Maximum value restriction.
     *
     * @type int64
     */
    maximum?: number;

    /**
     * Exclusive minimum value restriction.
     *
     * For reference, even though your Swagger document has defined the
     * `exclusiveMinimum` value as `number`, it has been forcibly converted
     * to `boolean` type, and assigns the numeric value to the
     * {@link minimum} property in the {@link OpenApi} conversion.
     */
    exclusiveMinimum?: boolean;

    /**
     * Exclusive maximum value restriction.
     *
     * For reference, even though your Swagger document has defined the
     * `exclusiveMaximum` value as `number`, it has been forcibly converted
     * to `boolean` type, and assigns the numeric value to the
     * {@link maximum} property in the {@link OpenApi} conversion.
     */
    exclusiveMaximum?: boolean;

    /**
     * Multiple of value restriction.
     *
     * @type uint64
     * @exclusiveMinimum 0
     */
    multipleOf?: number;
  }

  /**
   * Number type schema info.
   */
  export interface INumber extends __ISignificant<"number"> {
    /**
     * Default value.
     */
    default?: number | null;

    /**
     * Enumeration values.
     */
    enum?: Array<number | null>;

    /**
     * Minimum value restriction.
     */
    minimum?: number;

    /**
     * Maximum value restriction.
     */
    maximum?: number;

    /**
     * Exclusive minimum value restriction.
     *
     * For reference, even though your Swagger (or OpenAPI) document has
     * defined the `exclusiveMinimum` value as `number`, {@link OpenAiComposer}
     * forcibly converts it to `boolean` type, and assign the numeric value to
     * the {@link minimum} property.
     */
    exclusiveMinimum?: boolean;

    /**
     * Exclusive maximum value restriction.
     *
     * For reference, even though your Swagger (or OpenAPI) document has
     * defined the `exclusiveMaximum` value as `number`, {@link OpenAiComposer}
     * forcibly converts it to `boolean` type, and assign the numeric value to
     * the {@link maximum} property.
     */
    exclusiveMaximum?: boolean;

    /**
     * Multiple of value restriction.
     *
     * @exclusiveMinimum 0
     */
    multipleOf?: number;
  }

  /**
   * String type schema info.
   */
  export interface IString extends __ISignificant<"string"> {
    /**
     * Default value.
     */
    default?: string | null;

    /**
     * Enumeration values.
     */
    enum?: Array<string | null>;

    /**
     * Format restriction.
     */
    format?:
      | "binary"
      | "byte"
      | "password"
      | "regex"
      | "uuid"
      | "email"
      | "hostname"
      | "idn-email"
      | "idn-hostname"
      | "iri"
      | "iri-reference"
      | "ipv4"
      | "ipv6"
      | "uri"
      | "uri-reference"
      | "uri-template"
      | "url"
      | "date-time"
      | "date"
      | "time"
      | "duration"
      | "json-pointer"
      | "relative-json-pointer"
      | (string & {});

    /**
     * Pattern restriction.
     */
    pattern?: string;

    /**
     * Minimum length restriction.
     *
     * @type uint64
     */
    minLength?: number;

    /**
     * Maximum length restriction.
     *
     * @type uint64
     */
    maxLength?: number;

    /**
     * Content media type restriction.
     */
    contentMediaType?: string;
  }

  /**
   * Array type schema info.
   */
  export interface IArray<Schema extends ILlmSchema = ILlmSchema>
    extends __ISignificant<"array"> {
    /**
     * Items type schema info.
     *
     * The `items` means the type of the array elements. In other words, it is
     * the type schema info of the `T` in the TypeScript array type `Array<T>`.
     */
    items: Schema;

    /**
     * Unique items restriction.
     *
     * If this property value is `true`, target array must have unique items.
     */
    uniqueItems?: boolean;

    /**
     * Minimum items restriction.
     *
     * Restriction of minumum number of items in the array.
     *
     * @type uint64
     */
    minItems?: number;

    /**
     * Maximum items restriction.
     *
     * Restriction of maximum number of items in the array.
     *
     * @type uint64
     */
    maxItems?: number;
  }

  /**
   * Object type schema info.
   */
  export interface IObject<Schema extends ILlmSchema = ILlmSchema>
    extends __ISignificant<"object"> {
    /**
     * Properties of the object.
     *
     * The `properties` means a list of key-value pairs of the object's
     * regular properties. The key is the name of the regular property,
     * and the value is the type schema info.
     *
     * If you need additional properties that is represented by dynamic key,
     * you can use the {@link additionalProperties} instead.
     */
    properties?: Record<string, Schema>;

    /**
     * List of key values of the required properties.
     *
     * The `required` means a list of the key values of the required
     * {@link properties}. If some property key is not listed in the `required`
     * list, it means that property is optional. Otherwise some property key
     * exists in the `required` list, it means that the property must be filled.
     *
     * Below is an example of the {@link properties} and `required`.
     *
     * ```typescript
     * interface SomeObject {
     *   id: string;
     *   email: string;
     *   name?: string;
     * }
     * ```
     *
     * As you can see, `id` and `email` {@link properties} are {@link required},
     * so that they are listed in the `required` list.
     *
     * ```json
     * {
     *   "type": "object",
     *   "properties": {
     *     "id": { "type": "string" },
     *     "email": { "type": "string" },
     *     "name": { "type": "string" }
     *   },
     *   "required": ["id", "email"]
     * }
     * ```
     */
    required?: string[];

    /**
     * Additional properties' info.
     *
     * The `additionalProperties` means the type schema info of the additional
     * properties that are not listed in the {@link properties}.
     *
     * If the value is `true`, it means that the additional properties are not
     * restricted. They can be any type. Otherwise, if the value is
     * {@link ILlmSchema} type, it means that the additional properties must
     * follow the type schema info.
     *
     * - `true`: `Record<string, any>`
     * - `ILlmSchema`: `Record<string, T>`
     */
    additionalProperties?: boolean | Schema;
  }

  /**
   * Unknown type schema info.
   *
   * It means the type of the value is `any`.
   */
  export interface IUnknown extends __IAttribute {
    /**
     * Type is never be defined.
     */
    type?: undefined;
  }

  /**
   * Null only type schema info.
   */
  export interface INullOnly extends __IAttribute {
    /**
     * Type is always `null`.
     */
    type: "null";

    /**
     * Default value.
     */
    default?: null;
  }

  /**
   * One of type schema info.
   *
   * `IOneOf` represents an union type of the TypeScript (`A | B | C`).
   *
   * For reference, even though your Swagger (or OpenAPI) document has
   * defined `anyOf` instead of the `oneOf`, it has been forcibly converted
   * to `oneOf` type by {@link OpenApi.convert OpenAPI conversion}.
   */
  export interface IOneOf<Schema extends ILlmSchema = ILlmSchema>
    extends __IAttribute {
    /**
     * List of the union types.
     */
    oneOf: Exclude<Schema, ILlmSchema.IOneOf<Schema>>[];
  }

  /**
   * Significant attributes that can be applied to the most types.
   */
  export interface __ISignificant<Type extends string> extends __IAttribute {
    /**
     * Discriminator value of the type.
     */
    type: Type;

    /**
     * Whether to allow `null` value or not.
     */
    nullable?: boolean;
  }

  /**
   * Common attributes that can be applied to all types.
   */
  export interface __IAttribute {
    /**
     * Title of the schema.
     */
    title?: string;

    /**
     * Detailed description of the schema.
     */
    description?: string;

    /**
     * Whether the type is deprecated or not.
     */
    deprecated?: boolean;
  }
}
```
  </Tab>
</Tabs>

LLM function calling application from a native TypeScript class or interface type.

`typia.llm.application<App>()` is a function composing LLM (Large Language Model) calling application from a native TypeScript class or interface type. The function returns an `ILlmApplication` instance, which is a data structure representing a collection of LLM function calling schemas. 

If you put LLM function schema instances registered in the `ILlmApplication.functions` to the LLM provider like `OpenAI`, the LLM will select a proper function to call with parameter values of the target function in the conversations with the user. This is the "LLM Function Calling".

Let's make A.I. Chatbot super-easily with `typia.llm.application<App>()` function.

<Callout type="info">
**LLM Function Calling**

LLM selects proper function and fill arguments.

In nowadays, most LLM (Large Language Model) like OpenAI are supporting "function calling" feature. The "LLM function calling" means that LLM automatically selects a proper function and fills parameter values from conversation with the user (may by chatting text).

https://platform.openai.com/docs/guides/function-calling
</Callout>



## Description Comment
<Tabs items={[
    "TypeScript Source Code",
    "LLM Function Calling Application Schema",
  ]}>
  <Tab>
```typescript filename="example/src/llm.application.simple.ts" showLineNumbers {4}
import { ILlmApplication } from "@samchon/openapi";
import typia, { tags } from "typia";

const app: ILlmApplication = typia.llm.application<BbsArticleController>();

console.log(app);

interface BbsArticleController {
  /**
   * Create a new article.
   *
   * Writes a new article and archives it into the DB.
   *
   * @param input Information of the article to create
   * @returns Newly created article
   */
  create(input: IBbsArticle.ICreate): Promise<IBbsArticle>;

  /**
   * Update an article.
   *
   * Updates an article with new content.
   *
   * @param id Target article's {@link IBbsArticle.id}
   * @param input New content to update
   */
  update(
    id: string & tags.Format<"uuid">,
    input: IBbsArticle.IUpdate,
  ): Promise<void>;

  /**
   * Erase an article.
   *
   * Erases an article from the DB.
   *
   * @param id Target article's {@link IBbsArticle.id}
   */
  erase(id: string & tags.Format<"uuid">): Promise<void>;
}

/**
 * Article entity.
 *
 * `IBbsArticle` is an entity representing an article in the BBS (Bulletin Board System).
 */
interface IBbsArticle extends IBbsArticle.ICreate {
  /**
   * Primary Key.
   */
  id: string & tags.Format<"uuid">;

  /**
   * Creation time of the article.
   */
  created_at: string & tags.Format<"date-time">;

  /**
   * Last updated time of the article.
   */
  updated_at: string & tags.Format<"date-time">;
}
namespace IBbsArticle {
  /**
   * Information of the article to create.
   */
  export interface ICreate {
    /**
     * Title of the article.
     *
     * Representative title of the article.
     */
    title: string;

    /**
     * Content body.
     *
     * Content body of the article writtn in the markdown format.
     */
    body: string;

    /**
     * Thumbnail image URI.
     *
     * Thumbnail image URI which can represent the article.
     *
     * If configured as `null`, it means that no thumbnail image in the article.
     */
    thumbnail:
      | null
      | (string & tags.Format<"uri"> & tags.ContentMediaType<"image/*">);
  }

  /**
   * Information of the article to update.
   *
   * Only the filled properties will be updated.
   */
  export type IUpdate = Partial<ICreate>;
}
```
  </Tab>
  <Tab>
```json filename="example/schemas/llm.application.simple.json" showLineNumbers
{
  "functions": [
    {
      "name": "create",
      "parameters": [
        {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "title": "Title of the article",
              "description": "Title of the article.\n\nRepresentative title of the article."
            },
            "body": {
              "type": "string",
              "title": "Content body",
              "description": "Content body.\n\nContent body of the article writtn in the markdown format."
            },
            "thumbnail": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*",
              "nullable": true,
              "title": "Thumbnail image URI",
              "description": "Thumbnail image URI.\n\nThumbnail image URI which can represent the article.\n\nIf configured as `null`, it means that no thumbnail image in the article."
            }
          },
          "nullable": false,
          "required": [
            "title",
            "body",
            "thumbnail"
          ],
          "description": "Information of the article to create"
        }
      ],
      "output": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key",
            "description": "Primary Key."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of the article",
            "description": "Creation time of the article."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated time of the article",
            "description": "Last updated time of the article."
          },
          "title": {
            "type": "string",
            "title": "Title of the article",
            "description": "Title of the article.\n\nRepresentative title of the article."
          },
          "body": {
            "type": "string",
            "title": "Content body",
            "description": "Content body.\n\nContent body of the article writtn in the markdown format."
          },
          "thumbnail": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "image/*",
            "nullable": true,
            "title": "Thumbnail image URI",
            "description": "Thumbnail image URI.\n\nThumbnail image URI which can represent the article.\n\nIf configured as `null`, it means that no thumbnail image in the article."
          }
        },
        "nullable": false,
        "required": [
          "id",
          "created_at",
          "updated_at",
          "title",
          "body",
          "thumbnail"
        ],
        "description": "Newly created article"
      },
      "description": "Create a new article.\n\nWrites a new article and archives it into the DB."
    },
    {
      "name": "update",
      "parameters": [
        {
          "type": "string",
          "format": "uuid",
          "description": "Target article's "
        },
        {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "title": "Title of the article",
              "description": "Title of the article.\n\nRepresentative title of the article."
            },
            "body": {
              "type": "string",
              "title": "Content body",
              "description": "Content body.\n\nContent body of the article writtn in the markdown format."
            },
            "thumbnail": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*",
              "nullable": true,
              "title": "Thumbnail image URI",
              "description": "Thumbnail image URI.\n\nThumbnail image URI which can represent the article.\n\nIf configured as `null`, it means that no thumbnail image in the article."
            }
          },
          "nullable": false,
          "description": "New content to update"
        }
      ],
      "description": "Update an article.\n\nUpdates an article with new content."
    },
    {
      "name": "erase",
      "parameters": [
        {
          "type": "string",
          "format": "uuid",
          "description": "Target article's "
        }
      ],
      "description": "Erase an article.\n\nErases an article from the DB."
    }
  ],
  "options": {
    "separate": null
  }
}
```
  </Tab>
</Tabs>

Here is the example code utilizing the `typia.llm.application<App>()` function.

As you can see, above example code is writing detailed descriptions for every functions and their parameter/return types. Such detailed descriptions are very important to teach the purpose of the function to the LLM (Language Large Model), and LLM actually determines which function to call by the description. 

Therefore, don't forget to writing detailed descriptions. It's very import feature for the LLM function calling.




## Parameters' Separation
Parameter values from both LLM and Human sides.

When composing parameter arguments through the LLM (Large Language Model) function calling, there can be a case that some parameters (or nested properties) must be composed not by LLM, but by Human. File uploading feature, or sensitive information like secret key (password) cases are the representative examples.

In that case, you can configure the LLM function calling schemas to exclude such Human side parameters (or nested properties) by `ILlmApplication.options.separate` property. Instead, you have to merge both Human and LLM composed parameters into one by calling the `HttpLlm.mergeParameters()` before the LLM function call execution.

Here is the example separating the parameter schemas.

<Tabs items={[
    "TypeScript Source Code",
    "LLM Function Calling Application Schema",
  ]}>
  <Tab>
```typescript filename="example/src/llm.application.separate.ts" showLineNumbers {4-7}
import { ILlmApplication, ILlmSchema, LlmTypeChecker } from "@samchon/openapi";
import typia, { tags } from "typia";

const app: ILlmApplication = typia.llm.application<BbsArticleController>({
  separate: (schema: ILlmSchema) =>
    LlmTypeChecker.isString(schema) && schema.contentMediaType !== undefined,
});

console.log(app);

interface BbsArticleController {
  /**
   * Create a new article.
   *
   * Writes a new article and archives it into the DB.
   *
   * @param input Information of the article to create
   * @returns Newly created article
   */
  create(input: IBbsArticle.ICreate): Promise<IBbsArticle>;

  /**
   * Update an article.
   *
   * Updates an article with new content.
   *
   * @param id Target article's {@link IBbsArticle.id}
   * @param input New content to update
   */
  update(
    id: string & tags.Format<"uuid">,
    input: IBbsArticle.IUpdate,
  ): Promise<void>;

  /**
   * Erase an article.
   *
   * Erases an article from the DB.
   *
   * @param id Target article's {@link IBbsArticle.id}
   */
  erase(id: string & tags.Format<"uuid">): Promise<void>;
}
```
  </Tab>
  <Tab>
```json filename="example/schemas/llm.application.separate.json" showLineNumbers {41-91}
{
  "functions": [
    {
      "name": "create",
      "parameters": [
        {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "title": "Title of the article",
              "description": "Title of the article.\n\nRepresentative title of the article."
            },
            "body": {
              "type": "string",
              "title": "Content body",
              "description": "Content body.\n\nContent body of the article writtn in the markdown format."
            },
            "thumbnail": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*",
              "nullable": true,
              "title": "Thumbnail image URI",
              "description": "Thumbnail image URI.\n\nThumbnail image URI which can represent the article.\n\nIf configured as `null`, it means that no thumbnail image in the article."
            }
          },
          "nullable": false,
          "required": [
            "title",
            "body",
            "thumbnail"
          ],
          "description": "Information of the article to create"
        }
      ],
      "output": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "format": "uuid",
            "title": "Primary Key",
            "description": "Primary Key."
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Creation time of the article",
            "description": "Creation time of the article."
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Last updated time of the article",
            "description": "Last updated time of the article."
          },
          "title": {
            "type": "string",
            "title": "Title of the article",
            "description": "Title of the article.\n\nRepresentative title of the article."
          },
          "body": {
            "type": "string",
            "title": "Content body",
            "description": "Content body.\n\nContent body of the article writtn in the markdown format."
          },
          "thumbnail": {
            "type": "string",
            "format": "uri",
            "contentMediaType": "image/*",
            "nullable": true,
            "title": "Thumbnail image URI",
            "description": "Thumbnail image URI.\n\nThumbnail image URI which can represent the article.\n\nIf configured as `null`, it means that no thumbnail image in the article."
          }
        },
        "nullable": false,
        "required": [
          "id",
          "created_at",
          "updated_at",
          "title",
          "body",
          "thumbnail"
        ],
        "description": "Newly created article"
      },
      "description": "Create a new article.\n\nWrites a new article and archives it into the DB.",
      "separated": {
        "llm": [
          {
            "index": 0,
            "schema": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "title": "Title of the article",
                  "description": "Title of the article.\n\nRepresentative title of the article."
                },
                "body": {
                  "type": "string",
                  "title": "Content body",
                  "description": "Content body.\n\nContent body of the article writtn in the markdown format."
                }
              },
              "nullable": false,
              "required": [
                "title",
                "body"
              ],
              "description": "Information of the article to create"
            }
          }
        ],
        "human": [
          {
            "index": 0,
            "schema": {
              "type": "object",
              "properties": {
                "thumbnail": {
                  "type": "string",
                  "format": "uri",
                  "contentMediaType": "image/*",
                  "nullable": true,
                  "title": "Thumbnail image URI",
                  "description": "Thumbnail image URI.\n\nThumbnail image URI which can represent the article.\n\nIf configured as `null`, it means that no thumbnail image in the article."
                }
              },
              "nullable": false,
              "required": [
                "thumbnail"
              ],
              "description": "Information of the article to create"
            }
          }
        ]
      }
    },
    {
      "name": "update",
      "parameters": [
        {
          "type": "string",
          "format": "uuid",
          "description": "Target article's "
        },
        {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "title": "Title of the article",
              "description": "Title of the article.\n\nRepresentative title of the article."
            },
            "body": {
              "type": "string",
              "title": "Content body",
              "description": "Content body.\n\nContent body of the article writtn in the markdown format."
            },
            "thumbnail": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*",
              "nullable": true,
              "title": "Thumbnail image URI",
              "description": "Thumbnail image URI.\n\nThumbnail image URI which can represent the article.\n\nIf configured as `null`, it means that no thumbnail image in the article."
            }
          },
          "nullable": false,
          "description": "New content to update"
        }
      ],
      "description": "Update an article.\n\nUpdates an article with new content.",
      "separated": {
        "llm": [
          {
            "index": 0,
            "schema": {
              "type": "string",
              "format": "uuid",
              "description": "Target article's "
            }
          },
          {
            "index": 1,
            "schema": {
              "type": "object",
              "properties": {
                "title": {
                  "type": "string",
                  "title": "Title of the article",
                  "description": "Title of the article.\n\nRepresentative title of the article."
                },
                "body": {
                  "type": "string",
                  "title": "Content body",
                  "description": "Content body.\n\nContent body of the article writtn in the markdown format."
                }
              },
              "nullable": false,
              "description": "New content to update"
            }
          }
        ],
        "human": [
          {
            "index": 1,
            "schema": {
              "type": "object",
              "properties": {
                "thumbnail": {
                  "type": "string",
                  "format": "uri",
                  "contentMediaType": "image/*",
                  "nullable": true,
                  "title": "Thumbnail image URI",
                  "description": "Thumbnail image URI.\n\nThumbnail image URI which can represent the article.\n\nIf configured as `null`, it means that no thumbnail image in the article."
                }
              },
              "nullable": false,
              "description": "New content to update"
            }
          }
        ]
      }
    },
    {
      "name": "erase",
      "parameters": [
        {
          "type": "string",
          "format": "uuid",
          "description": "Target article's "
        }
      ],
      "description": "Erase an article.\n\nErases an article from the DB.",
      "separated": {
        "llm": [
          {
            "index": 0,
            "schema": {
              "type": "string",
              "format": "uuid",
              "description": "Target article's "
            }
          }
        ],
        "human": []
      }
    }
  ],
  "options": {}
}
```
  </Tab>
</Tabs>




## Function Hiding
Hiding some functions by comment tag.

If you write `@hidden` or `@internal` tag onto a function description comment, the function would not participate in the LLM (Large Language Model) function calling application composition. `ILlmFunction` schema does not be genrated in the `ILlmApplication.functions` collection.

It's a good feature to hide some internal functions, so that avoiding the LLM function calling.

<Tabs items={[
    "TypeScript Source Code",
    "LLM Function Calling Application Schema",
  ]}>
  <Tab>
```typescript filename="example/src/llm.application.hideden.ts" showLineNumbers {25, 38}
import { ILlmApplication } from "@samchon/openapi";
import typia, { tags } from "typia";

const app: ILlmApplication = typia.llm.application<BbsArticleController>();

console.log(app);

interface BbsArticleController {
  /**
   * Create a new article.
   *
   * Writes a new article and archives it into the DB.
   *
   * @param input Information of the article to create
   * @returns Newly created article
   */
  create(input: IBbsArticle.ICreate): Promise<IBbsArticle>;

  /**
   * Update an article.
   *
   * Updates an article with new content.
   *
   * @param id Target article's {@link IBbsArticle.id}
   * @param input New content to update
   * @hidden
   */
  update(
    id: string & tags.Format<"uuid">,
    input: IBbsArticle.IUpdate,
  ): Promise<void>;

  /**
   * Erase an article.
   *
   * Erases an article from the DB.
   *
   * @param id Target article's {@link IBbsArticle.id}
   * @internal
   */
  erase(id: string & tags.Format<"uuid">): Promise<void>;
}
```
  </Tab>
  <Tab>
```json filename="example/schemas/llm.application.hideden.json" showLineNumbers
{
  "functions": [
    {
      "name": "create",
      "parameters": [
        {
          "type": "object",
          "properties": {
            "title": {
              "type": "string",
              "title": "Title of the article",
              "description": "Title of the article.\n\nRepresentative title of the article."
            },
            "body": {
              "type": "string",
              "title": "Content body",
              "description": "Content body.\n\nContent body of the article writtn in the markdown format."
            },
            "thumbnail": {
              "type": "string",
              "format": "uri",
              "contentMediaType": "image/*",
              "nullable": true,
              "title": "Thumbnail image URI",
              "description": "Thumbnail image URI.\n\nThumbnail image URI which can represent the article.\n\nIf configured as `null`, it means that no thumbnail image in the article."     
            }
          },
          "nullable": false,
          "required": [
            "title",
            "body",
            "thumbnail"
          ],
          "description": "Information of the article to create"
        }
      ],
      "output": {
        "description": "Newly created article"
      },
      "description": "Create a new article.\n\nWrites a new article and archives it into the DB."
    }
  ],
  "options": {
    "separate": null
  }
}
```
  </Tab>
</Tabs>




## Restrictions
LLM schema does not support `bigint` type, and recursive type either.

LLM schema is based on the JSON schema definition of the OpenAPI v3.0 specification. Therefore, limitations of the JSON schema is also applied to the LLM schema, and the `bigint` type is not supported in the LLM function calling schema composition.

<Tabs items={["TypeScript Source Code", "Console Output"]}>
  <Tab>
```typescript filename="example/src/llm.application.bigint.ts" showLineNumbers
import typia from "typia";

typia.llm.application<Controller>();

interface Controller {
  plus(X: bigint, y: bigint): bigint;
}
```
  </Tab>
  <Tab>
```bash
src/llm.application.error.ts:3:1 - error TS(typia.llm.application): unsupported type detected

- Controller.plus: bigint(parameter: "X")
  - LLM schema does not support bigint type.

- Controller.plus: bigint(parameter: "y")
  - LLM schema does not support bigint type.

- Controller.plus: bigint(return type)
  - LLM schema does not support bigint type.

3 typia.llm.application<Controller>()
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Found 1 error in src/llm.application.error.ts:3 
```
  </Tab>
</Tabs>

Also, LLM schema does not support reference type that is embodied by the `OpenApi.IJsonSchema.IReference` type with `$ref` property. Therefore, if recursive type comes, no way to express it in the LLM schema, and it would be compilation error in the `typia.llm.application<App>()` function.

<Tabs items={["TypeScript Source Code", "Console Output"]}>
  <Tab>
```typescript filename="example/src/llm.application.bigint.ts" showLineNumbers
import typia from "typia";

typia.llm.application<Controller>();

interface Controller {
  plus(item: Recursive): Recursive;
}

interface Recursive {
  id: number;
  children: Recursive[];
}
```
  </Tab>
  <Tab>
```bash
src/llm.application.recursive.ts:3:1 - error TS(typia.llm.application): unsupported type detected

- Controller.plus: Recursive(parameter: "item")
  - LLM schema does not support recursive type.

- Recursive: Recursive
  - LLM schema does not support recursive type.

- Recursive.children: Recursive
  - LLM schema does not support recursive type.

- Controller.plus: Recursive(return type)
  - LLM schema does not support recursive type.

3 typia.llm.application<Controller>();
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Found 1 error in src/llm.application.recursive.ts:3
```
  </Tab>
</Tabs>

And if you put any type of native classes like `Map` or `Uint8Array`, it would also be error, either. By the way, only `Date` class type is exceptional, and it would be considered as `string & Format<"date-time">` type like below.

<Tabs items={["TypeScript Source Code", "Console Output"]}>
  <Tab>
```typescript filename="example/src/llm.application.bigint.ts" showLineNumbers
import { ILlmApplication } from "@samchon/openapi";
import typia from "typia";

const app: ILlmApplication = typia.llm.application<Controller>();

console.log(app);

interface Controller {
  now(): Date;
}
```
  </Tab>
  <Tab>
```json filename="example/schemas/llm.application.bigint.json" showLineNumbers
{
  "functions": [
    {
      "name": "now",
      "parameters": [],
      "output": {
        "type": "string",
        "format": "date-time"
      }
    }
  ],
  "options": {
    "separate": null
  }
}
```
  </Tab>
</Tabs>